#!/usr/local/bin/jimsh
# vim:ft=tcl foldmethod=marker

# jSQLsh - Jim TCL SQLite Shell {{{1
# Lorance Stinson - Lorance Stinson AT gmail DOT com
# This file is in the public domain.

# This is an SQLite shell for Jim TCL.
# For more on Jim see http://jim.berlios.de/

# There are things about the SQLite command shell that annoy me.
# Since there are no easily modified command line SQL clients,
# so I wrote my own. This is also my first foray in TCL programming.

# XXX Packages {{{1
package require readline
package require sqlite3

# XXX Configuration {{{1

# The configuration array. {{{2
# Note: Command /S will display all settings.
array set jsqlsh_config {
    auto        0
    buffer      ""
    buffer_prev ""
    db_name     ":memory:"
    debug       0
    dumb        0
    editor      ""
    escape      "\\\\"
    ext         ".sq3"
    header      1
    mode        "table"
    modes       "csv list table tcl"
    null        "NULL"
    page        1
    pager       ""
    ps1         "#"
    ps2         "?"
    quiet       1
    quiet_temp  0
    quote       "\""
    rows        0
    sep         ","
    term_height 0
    term_width  0
    trunc       0
}

# User Macros.
array set jsqlsh_user_macros {}

# User settable options. {{{2
# Contains the option names and descriptions.
# The word at the end is used in processing the options.
# Users can only set/see options defined in this array.
# Note: Command /S will display all settings.
array set jsqlsh_user_opts {
    auto    "Automatically execute SQL ending with ';'. Bool"
    debug   "Controls debugging mode. (Very Verbose!) Bool"
    editor  "The editor program for editing queries. Text"
    ext     "SQLite file extension. Text"
    escape  "The escape character for CSV mode. Text"
    header  "If table headers should be printed. Bool"
    null    "The value that represents SQL NULLs. Text"
    page    "Use the 'pager' program for long results. Bool"
    pager   "The pager program for long results. Text"
    ps1     "Main prompt. Text"
    ps2     "More prompt. Text"
    quiet   "Disables informational messages. Bool"
    quote   "The quote character for CSV mode. Text"
    sep     "Field separator for CSV & List modes. Text"
    trunc   "Truncate long rows to fit the screen. Bool"
}
set jsqlsh_user_opts(mode) "The output Format. ([join $jsqlsh_config(modes) ", "]) Text"

# Internal Queries {{{2
array set jsqlsh_queries {
describe_object
"SELECT
    m.name AS 'Name',
    upper(substr(m.type, 1, 1)) || lower(substr(m.type, 2)) AS 'Type',
    m.tbl_name AS 'Table'
FROM sqlite_master m
WHERE m.name = '%s'
ORDER BY m.type, m.name"
display_objects
"SELECT
    m.name AS 'Name',
    upper(substr(m.type, 1, 1)) || lower(substr(m.type, 2)) AS 'Type',
    m.tbl_name AS 'Table'
FROM sqlite_master m
WHERE m.name NOT LIKE 'sqlite_autoindex_%'
ORDER BY m.type, m.name"
display_indexes
"SELECT m.name AS 'Name', m.tbl_name AS 'Table'
FROM sqlite_master m
WHERE m.type = 'index'
ORDER BY m.name"
display_schema
"SELECT m.sql AS 'Schema'
FROM sqlite_master m
WHERE m.name = '%s'
ORDER BY m.type, m.name"
display_tables
"SELECT m.name AS 'Name'
FROM sqlite_master m
WHERE m.type = 'table'
ORDER BY m.name"
display_views
"SELECT m.name AS 'Name'
FROM sqlite_master m
WHERE m.type = 'view'
ORDER BY m.name"
}

# XXX Procedures {{{1

# jsqlsh.check_file - Check if a file exists and is readable. {{{2
# Returns a file name if a file is found.
# Trys the file name with the defailt extension if $try_ext.
proc jsqlsh.check_file {config file_name {try_ext 0}} {
    if {[file exists $file_name] && [file readable $file_name]} {
        return $file_name
    }

    set file_name "$file_name$config(ext)"
    if {$try_ext && [file exists $file_name] && [file readable $file_name]} {
        return $file_name
    }
    return ""
}

# jsqlsh.cmd_opts - Process command line options. {{{2
proc jsqlsh.cmd_opts {&config} {
    global argv
    if {$argv eq ""} { return }

    proc try_file {&config create_db arg} {
        set file_name [jsqlsh.check_file $config $arg 1]
        if {$create_db} {
            if {$file_name ne ""} {
                puts "The file '$file_name' already exists!"
                exit 1
            }
            set config(db_name) $file_name
        }
        if {$file_name ne ""} {
            set config(db_name) $file_name
        } else {
            jsqlsh.usage"Error: Could not read the file '$arg'!"
        }
    }

    set create_db 0
    set double_dash 0
    foreach arg $argv {
        if {$double_dash} {
            return [try_file config $create_db $arg]
        }
        switch -glob -- $arg {
            -a  { set config(auto) 1 }
            --h* -
            -h* { jsqlsh.usage }
            -c  { set create_db 1 }
            -d  { set config(dumb) 1; set config(auto) 1 }
            -D  { set config(debug) 1 }
            -q  { set config(quiet_temp) [set config(quiet) 1] }
            -s* { jsqlsh.handle_cmd_set config [
                    regsub "=" [string range $arg 2 end] " "] }
            --  { set double_dash 1 }
            -*  { jsqlsh.usage "Unknown option '$arg'." }
            default { try_file config $create_db $arg }
        }
    }
}

# jsqlsh.debug - Outputs debug information. {{{2
proc jsqlsh.debug {caller {output ""} args} {
    set dtime [clock format [clock seconds] -format "%Y-%m-%d %I:%M %p"]
    puts "DEBUG: ($caller) $dtime"
    if {$output ne ""} {
        foreach line [split $output "\n\r"] {
            puts "DEBUG: $line"
        }
    }
    if {[llength $args]} {
        foreach line $args {
            puts "ARGS: $line"
        }
    }
}

# jsqlsh.display - Display output from the database. {{{2
proc jsqlsh.display {&config output} {
    if {$output eq ""} { return 0 }

    set first [lindex $output 0]
    set headers {}
    set rows [llength $output]
    set cols [expr [llength $first] / 2]
    loop i 0 $cols {
        lappend headers [lindex $first [expr {$i * 2}]]
    }

    if {$config(mode) in $config(modes)} {
        set cmd "jsqlsh.display_$config(mode)"
    } else {
        puts "Unknown display mode '$config(mode)'."
        return $rows
    }
    if {$config(term_height) && $config(page) && $config(pager) ne "" &&
        $rows > ($config(term_height) - 3)} {
        catch -signal {
            set channel [open "| $config(pager)" "w"]
            $cmd $config $output $headers $channel
            close $channel
        }
    } else {
        $cmd $config $output $headers  "stdout"
    }

    return $rows
}

# jsqlsh.display_csv - Display output as csv. {{{2
proc jsqlsh.display_csv {config output headers channel} {
    proc list_to_csv {config row} {
        join [
            lmap col $row {
                if {[string match "*\[$config(sep)$config(quote)$config(escape) \]*" $col]} {
                    regsub -all "\[$config(quote)$config(escape)\]" $col "$config(escape)&" col
                    set col "\"$col\""
                } else {
                    set col
                }
            }
        ] $config(sep)
    }

    if {$config(header)} {
        puts $channel [list_to_csv $config $headers]
    }

    foreach row $output {
        puts $channel [list_to_csv $config [lmap col $headers {expr {"$row($col)"}}]]
    }
}

# jsqlsh.display_list - Display output as a list. {{{2
proc jsqlsh.display_list {config output headers channel} {
    if {$config(header)} {
        puts $channel [join $headers $config(sep)]
    }

    foreach row $output {
        puts $channel [join [lmap col $headers {expr {"$row($col)"}}] $config(sep)]
    }
}

# jsqlsh.display_table - Display output as a table. {{{2
proc jsqlsh.display_table {config output headers channel} {
    proc print_row {data {sep " |"}} {
        upvar channel channel
        puts $channel [string trimright [join [uplevel "lmap col \$headers {$data}"] $sep]]
    }

    # Set the column widths.
    array set col_width {}
    foreach col $headers {
        array set col_width($col) [string length $col]
    }
    foreach row $output {
        foreach col $headers {
            foreach line [split $row($col) "\n\r"] {
                set len [string length $line]
                if {$len > $col_width($col)} {
                    set col_width($col) $len
                }
            }
        }
    }

    # Try to truncate long lines if we exceed the display size.
    set trunc_size 0
    if {$config(trunc) && $config(term_width)} {
        set total_width -1
        set widest [lindex $headers 0]
        foreach col $headers {
            incr total_width $col_width($col)
            incr total_width 3
            if {$col_width($col) > $col_width($widest)} {
                set widest $col
            }
        }

        set trunc_size [expr {$total_width - $config(term_width) + 1}]
        if {$trunc_size > 0} {
            # Try truncating the widest row.
            if {$col_width($widest) > $trunc_size} {
                set col_width($widest) [expr {$col_width($widest) - $trunc_size}]
                puts $channel "NOTICE: Column '$widest' truncated by $trunc_size characters to $col_width($widest) characters."
                puts $channel ""
            }
        }
    }

    # Print the header.
    if {$config(header)} {
        print_row {format " %-*s" $col_width($col) $col}
        print_row {string repeat "-" [expr {$col_width($col) + 2}]} "+"
    }

    # Print the rows.
    # TODO Handle truncating multiline fields.
    if {$trunc_size > 0} {
        foreach row $output {
            print_row {format " %-*s" $col_width($col) [string range $row($col) 0 $col_width($col)]}
        }
    } else {
        foreach row $output {
            print_row {format " %-*s" $col_width($col) $row($col)}
        }
    }
}

# jsqlsh.display_tcl - Display output as a TCL list. {{{2
proc jsqlsh.display_tcl {config output headers channel} {
    if {$config(header)} {
        puts $channel [list $headers]
    }

    foreach row $output {
        puts $channel [list [lmap col $headers {set row($col)}]]
    }
}

# jsqlsh.dump_settings - Return the settings as a big string. {{{2
proc jsqlsh.dump_settings {config all} {
    global jsqlsh_user_opts
    if ($all) {
        set item_list [array names config]
    } else {
        set item_list [array names jsqlsh_user_opts]
    }

    foreach item [lsort $item_list] {
        set descr [expr {$all ? "" : $jsqlsh_user_opts($item)}]
        set value $config($item)
        set value "'$value'"
        if {$all && [string range $descr end-3 end] eq "Bool"} {
            set value [expr {$value ? "True" : "False"}]
        }
        puts [format "%-10s => %-10s %s" $item $value $descr]
    }
}

# jsqlsh.exec_query - Execute a query returning the output. {{{2
proc jsqlsh.exec_query {&config db query args} {
    if {[llength $args] == 0 || $args eq {{}} } {
        set query [jsqlsh.replace $query "%"]
    }
    if {$config(debug)} {
        jsqlsh.debug "jsqlsh.exec_query" $query $args
    }
    set ret [catch {$db query -null $config(null) $query $args} output]
    if {$ret} {
        puts "Query Error ($ret): $output"
        return ""
    }
    return $output
}

# jsqlsh.goodbye - Say goodbye and close the database. {{{2
proc jsqlsh.goodbye {&config db} {
    jsqlsh.put_info $config ""          \
                            "Goodbye!"
    $db close
    exit
}

# jsqlsh.handle_cmd_describe - Describe an object or lists objects. {{{2
proc jsqlsh.handle_cmd_describe {&config db input option} {
    global jsqlsh_queries
    set query ""
    set arg {}
    switch -glob -- $input {
        /d  { set query $jsqlsh_queries(display_objects) }
        /di { set query $jsqlsh_queries(display_indexes) }
        /dt { set query $jsqlsh_queries(display_tables) }
        /dv { set query $jsqlsh_queries(display_views) }
        /ds* {
            if {$option eq ""} {
                puts "Please provide an object to display schema for."
                return
            }
            set query $jsqlsh_queries(display_schema)
            set arg $option
        }
        default {
            if {$option eq ""} {
                puts "Please provide an object to describe."
                return
            }
            set query $jsqlsh_queries(describe_object)
            set arg $option
        }
    }

    if {$query ne ""} {
        set output [jsqlsh.exec_query config $db $query $arg]
        jsqlsh.display config $output
    }
}

# jsqlsh.handle_cmd_edit - Handle the user command '/edit'. {{{2
proc jsqlsh.handle_cmd_edit {&config} {
    if {$config(editor) eq ""} {
        puts "No editor defined. Can not edit the SQL buffer."
        return
    }

    set temp_name [file tempfile "/tmp/jsqlsh.tmp.XXXXXX"]
    set ret [catch {file rename $temp_name [set temp_name "$temp_name.sql"]}]
    if {$ret} {
        puts "Unable to create/rename a temporary file."
        return
    }

    if {![file owned $temp_name] || ![file writable $temp_name]} {
        puts "Error creating the temporary file."
        puts "Created '$temp_name' but now the permissions are wrong."
        puts "Aborting editing the buffer..."
        return
    }

    set temp_chan [open $temp_name "w"]
    if {$config(buffer) ne ""} {
        puts $temp_chan $config(buffer)
    } elseif {$config(buffer_prev) ne ""} {
        puts $temp_chan $config(buffer_prev)
    }
    close $temp_chan

    catch -signal {exec >@stdout 2>@stderr $config(editor) $temp_name}

    set temp_chan [open $temp_name "r"]
    set new_buffer [read -nonewline $temp_chan]
    close $temp_chan
    file delete $temp_name

    set config(buffer) $new_buffer
    jsqlsh.put_info $config "Query buffer now contains:"    \
                            $new_buffer                     \
                            ""
}

# jsqlsh.handle_cmd_go - Handle the user command '/go'. {{{2
proc jsqlsh.handle_cmd_go {&config db} {
    set output [jsqlsh.exec_query config $db $config(buffer)]
    set config(rows) [jsqlsh.display config $output]
    jsqlsh.put_info $config "$config(rows) row(s) returned"
    if {$config(buffer) ne $config(buffer_prev)} {
        readline.addhistory $config(buffer)
    }
    set config(buffer_prev) $config(buffer)
    set config(buffer) ""
    set config(prompt) $config(ps1)
}

# jsqlsh.handle_cmd_set - Handle the user command '/set'. {{{2
proc jsqlsh.handle_cmd_set {&config option} {
    global jsqlsh_user_opts

    # Display settings if no option.
    if {$option eq ""} {
        return [jsqlsh.dump_settings $config 0]
    }

    # Get the specified value, or present an error.
    if {[set index [string first " " $option]] > 0} {
        incr index
        set value [string trim [string range $option $index end]]
        set value [subst -nocommands -novariables $value]
        if {[string match {"*"} $value] && $value ne "\""} {
            set value [string range $value 1 end-1]
        }
        set option [string tolower [string range $option 0 [expr {$index - 2}]]]
    } else {
        puts "Usage: '/s Option Value'"
        puts "Both Option and Value must be specified."
        puts "Value is treated as a TCL string and may be quoted."
        return
    }

    # Make sure the option is valid.
    if {[array get jsqlsh_user_opts $option] eq ""} {
        puts "Invalid Option. Type '/s' for a list of options."
        return
    }

    # Adjust the value for specific options.
    set type [string range $jsqlsh_user_opts($option) end-3 end]
    if {$type eq "Bool"} {
        # Make Bool values 1 or 0.
        if {[string tolower $value ] in {1 true yes on}} {
            set value 1
        } else {
            set value 0
        }
    } elseif {$option eq "ext"} {
        # Make sure the file extension starts with '.'.
        if {[string index $value 0] ne "."} {
            set value ".$value"
        }
    } elseif {$option eq "escape"} {
        # Unfortunately '\' has to be doubled to work right.
        if {$value eq "\\"} {
            set value "\\\\"
        }
    } elseif {$option eq "mode"} {
        # Make sure the output mode is valid.
        set value [string tolower $value]
        if {[string tolower $value] ni $config(modes)} {
            puts "Invalid setting for 'mode'."
            puts "Must be one of ([join $config(modes) ", "])."
            return
        }
    }

    if {$config(debug)} {
        jsqlsh.debug "jsqlsh.handle_cmd_set" "Setting ($option) to '$value'"
    }
    set config($option) $value
}

# jsqlsh.handle_cmd_open - Handle the user command '/o'. {{{2
proc jsqlsh.handle_cmd_open {&config &db option} {
    # List files and directories if there are no files.
    if {$option eq ""} {
        puts "Pwd: [pwd]/ (*$config(ext))"
        set files [lmap file [glob -nocomplain "*"] {
            if {[file isdirectory $file]} {
                expr {"$file/"}
            } else {
                continue
            }
        }]
        if {$files ne ""} { puts $files }
        puts ""
        set files [glob -nocomplain "*$config(ext)"]
        if {$files ne ""} {
            puts $files
        } else {
            puts "No files found."
        }
        return
    }

    # If a directory CD there.
    if {[file isdirectory $option]} {
        puts "cd -> [pwd]"
        cd $option
        return
    }

    # Attempt to open the file.
    set file_name $option
    if {$file_name eq ":memory:" ||
        [set file_name [jsqlsh.check_file $config $option 1]] ne ""} {
        $db close
        set config(db_name) $file_name
        set db [jsqlsh.opendb config]
    } else {
        puts "Error: Could not read the file '$option'!"
    }
}

# jsqlsh.handle_cmd_user_macro - Handle user defined macros. {{{2
proc jsqlsh.handle_cmd_user_macro {&config input option} {
    global jsqlsh_user_macros

    if {[regexp {[0-9]+$} $input macro]} {
        if {$option ne ""} {
            # Defining a macro.
            if {$option eq "-"} {
                if {$config(buffer) ne ""} {
                    set jsqlsh_user_macros($macro) $config(buffer)
                } elseif {$config(buffer_prev) ne ""} {
                    set jsqlsh_user_macros($macro) $config(buffer_prev)
                } else {
                    puts "Empty buffer, nothing copied."
                    return
                }
            } else {
                set jsqlsh_user_macros($macro) $option
            }
            jsqlsh.put_info $config "Macro '/user$macro' set to:"   \
                                    $jsqlsh_user_macros($macro)     \
                                    ""
        } else {
            # Calling a macro.
            if {![exists jsqlsh_user_macros($macro)} {
                puts "Undefined user macro '$macro'."
                puts "Please define with '/user$macro -' to copy the query buffer"
                puts "or '/user$macro SQL' to set to specific SQL."
                return
            }

            set config(buffer) $jsqlsh_user_macros($macro)
            jsqlsh.put_info $config "Query buffer now contains:"    \
                                    $config(buffer)                 \
                                    ""
        }
        return
    }

    puts "User Macros:"
    foreach macro [array names jsqlsh_user_macros] {
        set lines [split $jsqlsh_user_macros($macro) "\r\n"]
        puts [format "/user%-3s => %s" $macro [lindex $lines 0]]
        foreach line [lrange $lines 1 end] {
            puts [format "%12s%s" " " $line]
        }
    }
}

# jsqlsh.handle_input - Handle user input. {{{2
# Returns 1 if the input should be added to the history.
proc jsqlsh.handle_input {&config &db input} {
    if {[string length $input] == 0} {
        return
    }

    # Check for commands.
    if {!$config(dumb) && [string index $input 0] eq "/"} {
        set option ""
        if {[set index [string first " " $input]] > 0} {
            set option [string trim [string range $input $index end]]
            set input [string trim [string range $input 0 $index]]
        }
        switch -glob -- $input {
            /A  { set config(auto) [expr {!$config(auto)}] }
            /c* { set config(buffer) ""; set config(prompt) $config(ps1) }
            /D  { set config(debug) [expr {!$config(debug)}] }
            /d* { jsqlsh.handle_cmd_describe config $db $input $option }
            /e* { jsqlsh.handle_cmd_edit config }
            /   -
            /go { jsqlsh.handle_cmd_go config $db; return }
            /\\? -
            /h* { jsqlsh.help }
            /o* { jsqlsh.handle_cmd_open config db $option }
            /P  { set config(page) [expr {!$config(page)}] }
            /p* { if {$config(buffer) ne ""} { puts $config(buffer) } }
            /Q* { set config(quiet_temp) [set config(quiet) [expr {!$config(quiet)}]] }
            /q* { jsqlsh.goodbye config $db }
            /s* { jsqlsh.handle_cmd_set config $option }
            /S* { puts [jsqlsh.dump_settings $config 1] }
            /u* { jsqlsh.handle_cmd_user_macro config $input $option }
            default { puts "Unknown option. Type '/h' for help"; return }
        
        }
        return 1
    }

    # Add the input to the buffer.
    if {$config(buffer) eq ""} {
        set config(buffer) $input
    } else {
        append config(buffer) \n $input
    }

    # If the buffer is not empty use the more prompt.
    if {$config(buffer) ne ""} {
        set config(prompt) $config(ps2)
    }
    return
}

# jsqlsh.help - Print the help text. {{{2
proc jsqlsh.help {} {
    puts "Commands:"
    puts "  /A          Toggle the auto option state."
    puts "  /c(lear)    Clear the query buffer"
    puts "  /D          Toggle the debug option state."
    puts "  /d          Display all objects in the database."
    puts "  /di         Display all indexes."
    puts "  /dt         Display all tables."
    puts "  /dv         Display all views."
    puts "  /d OBJ      Describe the object OBJ."
    puts "  /ds OBJ     Displays the schema for the object OBJ."
    puts "  /e(dit)     Edit the query buffer."
    puts "  /go | /     Execute the query."
    puts "  /h(elp)     Print this help text."
    puts "  /o(pen)     Open a database file, change directories and list files."
    puts "  /P          Toggle the page option state."
    puts "  /p(rint)    Print the query buffer."
    puts "  /s(et)      Set/List configuration options. '/s OPTION VALUE'"
    puts "              Values are treated as TCL strings and can be quoted."
    puts "  /Q          Toggle the quiet option state."
    puts "  /q(uit)     Quit jsqlsh. (Also Ctrl-D)"
    puts "  /u(ser)     Display the user macros."
    puts "  /u(ser)#    Copy user macro # into the query buffer."
    puts "  /u(ser)# -  Copy the query buffer, or supplied text, into macro #."
}

# jsqlsh.load_rc_file - Load the configuration file. {{{2
proc jsqlsh.load_rc_file {&config} {
    #puts "Loading configuration from '$config(rc_file)'."
    set db ""
    set rc_chan [open $config(rc_file) "r"]
    while {[gets $rc_chan line] >= 0} {
        set line [string trim $line]
        if {$line eq "" || [string index $line 0] eq "#"} {
            continue
        }
        if {[string index $line 0] ne "/"} {
            puts "Invalid line: $line"
            puts "Configuration must be valid jSQLsh '/' commands."
            continue
        }

        jsqlsh.handle_input config db $line
    }
    close $rc_chan
}

# jsqlsh.opendb - Open the database. {{{2
proc jsqlsh.opendb {&config} {
    jsqlsh.put_info $config "Opening the database '$config(db_name)'."
    set ret [catch {set db [sqlite3.open $config(db_name)]} error]
    if {$ret != 0} {
        puts "Error opening the database!"
        puts "Code: $ret Error: $error"
        exit 1
    }
    if {[env HOME ""] ne ""} {
        set config(db_name) [jsqlsh.replace $config(db_name) [env HOME] "~"]
    }
    return $db
}

# jsqlsh.prompt - Prompt the user and return their input. {{{2
proc jsqlsh.prompt {&config db} {
    set prompt [
        format "%s (%d rows, %d changes) %s%s "         \
                $config(db_name)                        \
                $config(rows)                           \
                [$db changes]                           \
                [expr {$config(debug) ? "DEBUG " : ""}] \
                $config(prompt)
    ]

    set ret [catch -exit {readline.readline $prompt} output]

    if {$ret == 6} {
        # User pressed Ctrl-D.
        puts ""
        jsqlsh.goodbye config $db
    } elseif {$ret != 0} {
        puts ""
        puts "Readline Error ($ret): $output"
        exit 1
    }

    return $output
}

# jsqlsh.put_info - Print informational text if config(quiet) is not set. {{{2
proc jsqlsh.put_info {config args} {
    if {!$config(quiet)} {
        foreach arg $args {
            puts $arg
        }
    }
}

# jsqlsh.shell - The main loop to handle user input. {{{2
proc jsqlsh.shell {&config} {
    # Open the database.
    set db [jsqlsh.welcome config]

    # Infinite loop!
    set prev_input ""
    while 1 {
        # Prompt for user input.
        set input [jsqlsh.prompt config $db]

        # Handle their input.
        if {[jsqlsh.handle_input config db $input] ne ""} {
            if {$input ne $prev_input} {
                readline.addhistory $input
            }
            set prev_input $input
        }

        # Execute the SQL if auto mode and a ';' is present.
        if {$config(auto) && [string index $config(buffer) end] eq ";"} {
            jsqlsh.handle_cmd_go config $db
        }
    }
}

# jsqlsh.replace - Replace a character or string in the input string. {{{2
# Special case: If no replace then replace search with search doubled.
proc jsqlsh.replace {input search args} {
    set output ""
    set prev 0
    set pos 0
    if {[llength $args] == 0} {
        set replace [string repeat $search 2]
    } else {
        set replace [lindex $args 0]
    }
    set search_len [string length $search]
    while {[set pos [string first $search $input $prev]] >= 0} {
        incr pos -1
        append output [string range $input $prev $pos] $replace
        set prev [expr {$pos + $search_len + 1}]
    }
    if {$prev == 0} {return $input}
    append output [string range $input $prev end]
    return $output
}

# jsqlsh.term_info - Get the terminal information. {{{2
proc jsqlsh.term_info {&config} {
    if {[catch {set stty [exec "stty" "-a"]}]} {
        puts "Unable to determine terminal size!"
        return
    }
    foreach item [split $stty ";"] {
        set temp [split [string trim $item] " "]
        if {[lindex $temp 0] eq "rows"} {
            set config(term_height) [lindex $temp 1]
        }
        if {[lindex $temp 0] eq "columns"} {
            set config(term_width) [lindex $temp 1]
            break
        }
    }
}

# jsqlsh.usage - Print the command line usage. {{{2
proc jsqlsh.usage {{comment ""}} {
    global argv0

    if {$comment ne ""} {
        puts $comment
        puts ""
    }

    puts "Usage: [file tail $argv0] \[Options\] \[SQLite File\]"
    puts ""
    puts "Open the specified SQLite database file."
    puts "The file must exist, see the '-c' option."
    puts "Defaults to an in-memory database."
    puts ""
    puts "Options:"
    puts "    -a            Enable execution of queries ending with ';'. (auto)"
    puts "    -c            Create the database file. Fails if the file exists."
    puts "    -d            Disable slash commands and enable auto execution."
    puts "    -D            Debug mode. (Copious output!)"
    puts "    -h            Display this text."
    puts "    -s'opt=val'   Set an option as in the '/s' command."
    puts "                  Must be formatted as specified."
    exit 1
}

# jsqlsh.welcome - Print the welcome message and open the database. {{{2
proc jsqlsh.welcome {&config} {
    jsqlsh.put_info $config "Welcome to the SQLite Shell in Jim TCL [info version]."
    set db [jsqlsh.opendb config]
    jsqlsh.put_info $config "To execute the query type '/'."    \
                            "For help type '/h'."               \
                            ""

    return $db
}

# XXX Startup and Initialization {{{1

# Set defaults.
set jsqlsh_config(editor) [env EDITOR "vi"]
set jsqlsh_config(pager) [env PAGER "more"]
set jsqlsh_config(rc_file) "[env HOME ""]/.[file tail $argv0]rc"
jsqlsh.term_info jsqlsh_config

# Read the rc file.
if {[jsqlsh.check_file $jsqlsh_config $jsqlsh_config(rc_file)] ne ""} {
    jsqlsh.load_rc_file jsqlsh_config
}

# Process command line options.
jsqlsh.cmd_opts jsqlsh_config

# The initial prompt.
set jsqlsh_config(prompt) $jsqlsh_config(ps1)

# Show all settings on Debug mode.
if {$jsqlsh_config(debug)} {
    jsqlsh.debug "Configuration" [jsqlsh.dump_settings $jsqlsh_config 1]
}

# Quiet is in effect during initialization.
# Don't want to flood the user with garbage.
#
# After initialization set quiet to quiet_temp.
# Quiet_temp is set by the command line options
# and the user input handler.
# So if the user really wants "quiet" they get it.
set jsqlsh_config(quiet) $jsqlsh_config(quiet_temp)

# Start the shell.
signal ignore SIGINT
jsqlsh.shell jsqlsh_config
